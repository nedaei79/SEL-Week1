# آزمایش اول - آزمایشگاه مهندسی نرم‌افزار
اعضای گروه: امیرحسین ندایی پور، علی مهربانی

## گزارش روال انجام آزمایش
### ایجاد مخزن، فایل .gitignore، فایل README و قالب اولیه کد
بعد از ایجاد مخزن، آن را روی دستگاه خود clone کردیم و مشاهده می‌کنید که فولدر .git هم ساخته شده است:
<img width="960" alt="1clone-dotgit" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/d75fdc8d-8e37-41da-964d-5a7cb8c78507">

در مراحل بعدی فایل .gitignore را ساختیم و محتویات پوشه report-images را که شامل screenshot های استفاده شده در همین گزارش است را ignore کردیم تا به مخزن remote افزوده نشوند:
<img width="960" alt="2gitignore" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/0d29cb21-1434-409a-b101-5c2fcbb85d5b">

<img width="960" alt="3ignore-report-images" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/e88ab2ed-52b0-4bdd-83ee-54c0b535353a">

<img width="960" alt="3commit-gitignore" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/870a72c3-ca07-4803-8f36-1472f7e803df">

در مرحله بعد فایل README را به پروژه افزودیم تا بعد از انجام پروژه گزارش را در آن تکمیل کنیم:
<img width="960" alt="4readme" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/4f57e212-dea5-407b-a7ac-e8d4fe2fb636">

سپس بدنه اصلی برنامه را در فایل main.py ساختیم که شامل دو تابع پیاده‌سازی نشده بود که در ادامه توسط دو عضو گروه در دو شاخه جداگانه توسعه داده می‌شوند:
<img width="960" alt="6main" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/23fbc67c-e6a9-4891-ace3-e2226e01bb17">

در نهایت هم برای محافظت از شاخه master یک rule به آن اضافه می‌کنیم که توسعه‌دهندگان را ملزم می‌کند قبل از مرج با master یک pull request ثبت کنند:
<img width="960" alt="0pull-request" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/c7d541a2-477e-4b35-a8dd-da3ab7c82312">

### ایجاد شاخه dev، توسعه و merge آن


### ایجاد شاخه feature، توسعه و merge آن


### ایجاد تغییر مختصر با هدف برخوردن به conflict دوم


## پاسخ پرسش‌ها
### پرسش یک


### پرسش دو

منظور از atomic commit این است که تغییرات موجود در هر commit تا جای ممکن کوچک باشد و بتوان آن را کاملا ساده در حد یک جمله در همان commit کامنت کرد. این کار به واضح بودن تغییرات اعمال شده در هر commit برای توسعه دهندگان کمک می‌کند. مشابه آن، مفهوم atomic pull request را داریم که به معنی حداقلی بودن تغییرات موجود در هر pull request است، به صورتی که بتوان تغییرات را در چند دقیقه مرور کرد. با این کار تغییرات موجود برای reviewer گیج‌کننده نخواهد بود و فهم آن را راحت‌تر می‌کند.

### پرسش سه


### پرسش چهار

هر سه دستور اشاره شده به ما کمک می‌کنند تغییرات ناخواسته ایجاد شده را اصلاح کنیم. اما به صورت خلاصه عملکرد هر دستور به این صورت است:

- دستور reset: این دستور به ما کمک می‌کند HEAD را به صورتی جابجا کنیم که commitهایی را به شاخه اضافه یا از آن حذف کنیم. در نتیجه این دستور در تاریخچه commitها تغییر ایجاد می‌کند.
- دستور restore: این دستور به ما کمک می‌کند فایل‌هایی را که به اشتباه staged شده‌اند را از این وضعیت خارج کنیم. این دستور در برخی حالات می‌تواند موجب از دست رفتن تغییرات اعمال شده در فایل‌ها شود و همچنین تاریخچه شاخه را تغییر نمی‌دهد.
- دستور revert: این دستور به ما کمک می‌کند تا تغییرات اعمال شده در commitهای دلخواه گذشته را در قالب یک commit جدید به حالت قبل برگردانیم. در نتیجه این دستور تاریخچه commitها را تغییر نمی‌دهد.


### پرسش پنج


### پرسش شش

  منظور از snapshot، وضعیت فایل‌های مخزن در هر مرحله از توسعه آن‌هاست. در واقع ما با ایجاد تغییر و commit کردن آن‌ها، فایل‌های مخزن را از یک وضعیت، به وضعیتی جدیتر می‌بریم. در نتیجه هر commit نشان‌دهنده یک snapshot از وضعیت فایل‌های مخزن است که می‌توان به آن ارجاع داد.
