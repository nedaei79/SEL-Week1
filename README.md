# آزمایش اول - آزمایشگاه مهندسی نرم‌افزار
اعضای گروه: امیرحسین ندایی پور، علی مهربانی

## گزارش روال انجام آزمایش
### ایجاد مخزن، فایل .gitignore، فایل README و قالب اولیه کد
بعد از ایجاد مخزن، آن را روی دستگاه خود clone کردیم و مشاهده می‌کنید که فولدر .git هم ساخته شده است:
<img width="960" alt="1clone-dotgit" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/d75fdc8d-8e37-41da-964d-5a7cb8c78507">

در مراحل بعدی فایل .gitignore را ساختیم و محتویات پوشه report-images را که شامل screenshot های استفاده شده در همین گزارش است را ignore کردیم تا به مخزن remote افزوده نشوند:
<img width="960" alt="2gitignore" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/0d29cb21-1434-409a-b101-5c2fcbb85d5b">

<img width="960" alt="3ignore-report-images" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/e88ab2ed-52b0-4bdd-83ee-54c0b535353a">

<img width="960" alt="3commit-gitignore" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/870a72c3-ca07-4803-8f36-1472f7e803df">

در مرحله بعد فایل README را به پروژه افزودیم تا بعد از انجام پروژه گزارش را در آن تکمیل کنیم:
<img width="960" alt="4readme" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/4f57e212-dea5-407b-a7ac-e8d4fe2fb636">

سپس بدنه اصلی برنامه را در فایل main.py ساختیم که شامل دو تابع پیاده‌سازی نشده بود که در ادامه توسط دو عضو گروه در دو شاخه جداگانه توسعه داده می‌شوند:
<img width="960" alt="6main" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/23fbc67c-e6a9-4891-ace3-e2226e01bb17">

در نهایت هم برای محافظت از شاخه master یک rule به آن اضافه می‌کنیم که توسعه‌دهندگان را ملزم می‌کند قبل از مرج با master یک pull request ثبت کنند:
<img width="960" alt="0pull-request" src="https://github.com/nedaei79/SEL-Week1/assets/62210316/c7d541a2-477e-4b35-a8dd-da3ab7c82312">

### ایجاد شاخه dev، توسعه و merge آن


### ایجاد شاخه feature، توسعه و merge آن


### ایجاد تغییر مختصر با هدف برخوردن به conflict دوم


## پاسخ پرسش‌ها
### پرسش یک


### پرسش دو

منظور از atomic commit این است که تغییرات موجود در هر commit تا جای ممکن کوچک باشد و بتوان آن را کاملا ساده در حد یک جمله در همان commit کامنت کرد. این کار به واضح بودن تغییرات اعمال شده در هر commit برای توسعه دهندگان کمک می‌کند. مشابه آن، مفهوم atomic pull request را داریم که به معنی حداقلی بودن تغییرات موجود در هر pull request است، به صورتی که بتوان تغییرات را در چند دقیقه مرور کرد. با این کار تغییرات موجود برای reviewer گیج‌کننده نخواهد بود و فهم آن را راحت‌تر می‌کند.

### پرسش سه


### پرسش چهار


### پرسش پنج


### پرسش شش

